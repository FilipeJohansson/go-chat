// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: packets.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "packets";

/** WS */
export interface ChatMessage {
  timestamp: Date | undefined;
  senderUsername: string;
  msg: string;
}

export interface IdMessage {
  id: number;
  username: string;
  room: RoomRegisteredMessage | undefined;
}

export interface RegisterMessage {
  id: number;
  username: string;
}

export interface UnregisterMessage {
  id: number;
}

export interface RoomRegisteredMessage {
  id: number;
  ownerId: string;
  name: string;
}

/** HTTP */
export interface JwtMessage {
  accessToken: string;
  refreshToken: string;
}

export interface LoginRequestMessage {
  username: string;
  password: string;
}

export interface RegisterRequestMessage {
  username: string;
  password: string;
}

export interface RefreshRequestMessage {
}

export interface LogoutRequestMessage {
}

export interface NewRoomRequestMessage {
  roomId: number;
  name: string;
}

export interface NewRoomResponseMessage {
  roomId: number;
  ownerId: string;
  name: string;
}

export interface RoomsRequestMessage {
}

export interface RoomsResponseMessage {
  rooms: NewRoomResponseMessage[];
}

export interface OkResponseMessage {
}

export interface DenyResponseMessage {
  reason: string;
}

export interface Packet {
  senderId: number;
  roomId: number;
  chat?: ChatMessage | undefined;
  id?: IdMessage | undefined;
  register?: RegisterMessage | undefined;
  unregister?: UnregisterMessage | undefined;
  okResponse?: OkResponseMessage | undefined;
  denyResponse?: DenyResponseMessage | undefined;
}

export interface Message {
  jwt?: JwtMessage | undefined;
  login?: LoginRequestMessage | undefined;
  register?: RegisterRequestMessage | undefined;
  refresh?: RefreshRequestMessage | undefined;
  logout?: LogoutRequestMessage | undefined;
  newRoom?: NewRoomRequestMessage | undefined;
  roomsRequest?: RoomsRequestMessage | undefined;
  roomsResponse?: RoomsResponseMessage | undefined;
  okResponse?: OkResponseMessage | undefined;
  denyResponse?: DenyResponseMessage | undefined;
}

function createBaseChatMessage(): ChatMessage {
  return { timestamp: undefined, senderUsername: "", msg: "" };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(message: ChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.senderUsername !== "") {
      writer.uint32(18).string(message.senderUsername);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderUsername = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      senderUsername: isSet(object.senderUsername) ? globalThis.String(object.senderUsername) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.senderUsername !== "") {
      obj.senderUsername = message.senderUsername;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.timestamp = object.timestamp ?? undefined;
    message.senderUsername = object.senderUsername ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseIdMessage(): IdMessage {
  return { id: 0, username: "", room: undefined };
}

export const IdMessage: MessageFns<IdMessage> = {
  encode(message: IdMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.room !== undefined) {
      RoomRegisteredMessage.encode(message.room, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.room = RoomRegisteredMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      room: isSet(object.room) ? RoomRegisteredMessage.fromJSON(object.room) : undefined,
    };
  },

  toJSON(message: IdMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.room !== undefined) {
      obj.room = RoomRegisteredMessage.toJSON(message.room);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdMessage>, I>>(base?: I): IdMessage {
    return IdMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdMessage>, I>>(object: I): IdMessage {
    const message = createBaseIdMessage();
    message.id = object.id ?? 0;
    message.username = object.username ?? "";
    message.room = (object.room !== undefined && object.room !== null)
      ? RoomRegisteredMessage.fromPartial(object.room)
      : undefined;
    return message;
  },
};

function createBaseRegisterMessage(): RegisterMessage {
  return { id: 0, username: "" };
}

export const RegisterMessage: MessageFns<RegisterMessage> = {
  encode(message: RegisterMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: RegisterMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterMessage>, I>>(base?: I): RegisterMessage {
    return RegisterMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterMessage>, I>>(object: I): RegisterMessage {
    const message = createBaseRegisterMessage();
    message.id = object.id ?? 0;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseUnregisterMessage(): UnregisterMessage {
  return { id: 0 };
}

export const UnregisterMessage: MessageFns<UnregisterMessage> = {
  encode(message: UnregisterMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnregisterMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterMessage {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: UnregisterMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnregisterMessage>, I>>(base?: I): UnregisterMessage {
    return UnregisterMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnregisterMessage>, I>>(object: I): UnregisterMessage {
    const message = createBaseUnregisterMessage();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseRoomRegisteredMessage(): RoomRegisteredMessage {
  return { id: 0, ownerId: "", name: "" };
}

export const RoomRegisteredMessage: MessageFns<RoomRegisteredMessage> = {
  encode(message: RoomRegisteredMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.ownerId !== "") {
      writer.uint32(18).string(message.ownerId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomRegisteredMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomRegisteredMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomRegisteredMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: RoomRegisteredMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomRegisteredMessage>, I>>(base?: I): RoomRegisteredMessage {
    return RoomRegisteredMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomRegisteredMessage>, I>>(object: I): RoomRegisteredMessage {
    const message = createBaseRoomRegisteredMessage();
    message.id = object.id ?? 0;
    message.ownerId = object.ownerId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseJwtMessage(): JwtMessage {
  return { accessToken: "", refreshToken: "" };
}

export const JwtMessage: MessageFns<JwtMessage> = {
  encode(message: JwtMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtMessage {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: JwtMessage): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtMessage>, I>>(base?: I): JwtMessage {
    return JwtMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtMessage>, I>>(object: I): JwtMessage {
    const message = createBaseJwtMessage();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseLoginRequestMessage(): LoginRequestMessage {
  return { username: "", password: "" };
}

export const LoginRequestMessage: MessageFns<LoginRequestMessage> = {
  encode(message: LoginRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequestMessage {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginRequestMessage): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequestMessage>, I>>(base?: I): LoginRequestMessage {
    return LoginRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequestMessage>, I>>(object: I): LoginRequestMessage {
    const message = createBaseLoginRequestMessage();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRegisterRequestMessage(): RegisterRequestMessage {
  return { username: "", password: "" };
}

export const RegisterRequestMessage: MessageFns<RegisterRequestMessage> = {
  encode(message: RegisterRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequestMessage {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: RegisterRequestMessage): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterRequestMessage>, I>>(base?: I): RegisterRequestMessage {
    return RegisterRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterRequestMessage>, I>>(object: I): RegisterRequestMessage {
    const message = createBaseRegisterRequestMessage();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRefreshRequestMessage(): RefreshRequestMessage {
  return {};
}

export const RefreshRequestMessage: MessageFns<RefreshRequestMessage> = {
  encode(_: RefreshRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefreshRequestMessage {
    return {};
  },

  toJSON(_: RefreshRequestMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshRequestMessage>, I>>(base?: I): RefreshRequestMessage {
    return RefreshRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshRequestMessage>, I>>(_: I): RefreshRequestMessage {
    const message = createBaseRefreshRequestMessage();
    return message;
  },
};

function createBaseLogoutRequestMessage(): LogoutRequestMessage {
  return {};
}

export const LogoutRequestMessage: MessageFns<LogoutRequestMessage> = {
  encode(_: LogoutRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogoutRequestMessage {
    return {};
  },

  toJSON(_: LogoutRequestMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequestMessage>, I>>(base?: I): LogoutRequestMessage {
    return LogoutRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequestMessage>, I>>(_: I): LogoutRequestMessage {
    const message = createBaseLogoutRequestMessage();
    return message;
  },
};

function createBaseNewRoomRequestMessage(): NewRoomRequestMessage {
  return { roomId: 0, name: "" };
}

export const NewRoomRequestMessage: MessageFns<NewRoomRequestMessage> = {
  encode(message: NewRoomRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== 0) {
      writer.uint32(8).uint64(message.roomId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewRoomRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewRoomRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewRoomRequestMessage {
    return {
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: NewRoomRequestMessage): unknown {
    const obj: any = {};
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewRoomRequestMessage>, I>>(base?: I): NewRoomRequestMessage {
    return NewRoomRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewRoomRequestMessage>, I>>(object: I): NewRoomRequestMessage {
    const message = createBaseNewRoomRequestMessage();
    message.roomId = object.roomId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseNewRoomResponseMessage(): NewRoomResponseMessage {
  return { roomId: 0, ownerId: "", name: "" };
}

export const NewRoomResponseMessage: MessageFns<NewRoomResponseMessage> = {
  encode(message: NewRoomResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== 0) {
      writer.uint32(8).uint64(message.roomId);
    }
    if (message.ownerId !== "") {
      writer.uint32(18).string(message.ownerId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewRoomResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewRoomResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewRoomResponseMessage {
    return {
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: NewRoomResponseMessage): unknown {
    const obj: any = {};
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewRoomResponseMessage>, I>>(base?: I): NewRoomResponseMessage {
    return NewRoomResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewRoomResponseMessage>, I>>(object: I): NewRoomResponseMessage {
    const message = createBaseNewRoomResponseMessage();
    message.roomId = object.roomId ?? 0;
    message.ownerId = object.ownerId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRoomsRequestMessage(): RoomsRequestMessage {
  return {};
}

export const RoomsRequestMessage: MessageFns<RoomsRequestMessage> = {
  encode(_: RoomsRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomsRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomsRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RoomsRequestMessage {
    return {};
  },

  toJSON(_: RoomsRequestMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomsRequestMessage>, I>>(base?: I): RoomsRequestMessage {
    return RoomsRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomsRequestMessage>, I>>(_: I): RoomsRequestMessage {
    const message = createBaseRoomsRequestMessage();
    return message;
  },
};

function createBaseRoomsResponseMessage(): RoomsResponseMessage {
  return { rooms: [] };
}

export const RoomsResponseMessage: MessageFns<RoomsResponseMessage> = {
  encode(message: RoomsResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rooms) {
      NewRoomResponseMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomsResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomsResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rooms.push(NewRoomResponseMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomsResponseMessage {
    return {
      rooms: globalThis.Array.isArray(object?.rooms)
        ? object.rooms.map((e: any) => NewRoomResponseMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoomsResponseMessage): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => NewRoomResponseMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoomsResponseMessage>, I>>(base?: I): RoomsResponseMessage {
    return RoomsResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomsResponseMessage>, I>>(object: I): RoomsResponseMessage {
    const message = createBaseRoomsResponseMessage();
    message.rooms = object.rooms?.map((e) => NewRoomResponseMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOkResponseMessage(): OkResponseMessage {
  return {};
}

export const OkResponseMessage: MessageFns<OkResponseMessage> = {
  encode(_: OkResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OkResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOkResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OkResponseMessage {
    return {};
  },

  toJSON(_: OkResponseMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OkResponseMessage>, I>>(base?: I): OkResponseMessage {
    return OkResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OkResponseMessage>, I>>(_: I): OkResponseMessage {
    const message = createBaseOkResponseMessage();
    return message;
  },
};

function createBaseDenyResponseMessage(): DenyResponseMessage {
  return { reason: "" };
}

export const DenyResponseMessage: MessageFns<DenyResponseMessage> = {
  encode(message: DenyResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyResponseMessage {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: DenyResponseMessage): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DenyResponseMessage>, I>>(base?: I): DenyResponseMessage {
    return DenyResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DenyResponseMessage>, I>>(object: I): DenyResponseMessage {
    const message = createBaseDenyResponseMessage();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBasePacket(): Packet {
  return {
    senderId: 0,
    roomId: 0,
    chat: undefined,
    id: undefined,
    register: undefined,
    unregister: undefined,
    okResponse: undefined,
    denyResponse: undefined,
  };
}

export const Packet: MessageFns<Packet> = {
  encode(message: Packet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.senderId !== 0) {
      writer.uint32(8).uint64(message.senderId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).uint64(message.roomId);
    }
    if (message.chat !== undefined) {
      ChatMessage.encode(message.chat, writer.uint32(26).fork()).join();
    }
    if (message.id !== undefined) {
      IdMessage.encode(message.id, writer.uint32(34).fork()).join();
    }
    if (message.register !== undefined) {
      RegisterMessage.encode(message.register, writer.uint32(42).fork()).join();
    }
    if (message.unregister !== undefined) {
      UnregisterMessage.encode(message.unregister, writer.uint32(50).fork()).join();
    }
    if (message.okResponse !== undefined) {
      OkResponseMessage.encode(message.okResponse, writer.uint32(58).fork()).join();
    }
    if (message.denyResponse !== undefined) {
      DenyResponseMessage.encode(message.denyResponse, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Packet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.senderId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chat = ChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = IdMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.register = RegisterMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unregister = UnregisterMessage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.okResponse = OkResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.denyResponse = DenyResponseMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Packet {
    return {
      senderId: isSet(object.senderId) ? globalThis.Number(object.senderId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      chat: isSet(object.chat) ? ChatMessage.fromJSON(object.chat) : undefined,
      id: isSet(object.id) ? IdMessage.fromJSON(object.id) : undefined,
      register: isSet(object.register) ? RegisterMessage.fromJSON(object.register) : undefined,
      unregister: isSet(object.unregister) ? UnregisterMessage.fromJSON(object.unregister) : undefined,
      okResponse: isSet(object.okResponse) ? OkResponseMessage.fromJSON(object.okResponse) : undefined,
      denyResponse: isSet(object.denyResponse) ? DenyResponseMessage.fromJSON(object.denyResponse) : undefined,
    };
  },

  toJSON(message: Packet): unknown {
    const obj: any = {};
    if (message.senderId !== 0) {
      obj.senderId = Math.round(message.senderId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.chat !== undefined) {
      obj.chat = ChatMessage.toJSON(message.chat);
    }
    if (message.id !== undefined) {
      obj.id = IdMessage.toJSON(message.id);
    }
    if (message.register !== undefined) {
      obj.register = RegisterMessage.toJSON(message.register);
    }
    if (message.unregister !== undefined) {
      obj.unregister = UnregisterMessage.toJSON(message.unregister);
    }
    if (message.okResponse !== undefined) {
      obj.okResponse = OkResponseMessage.toJSON(message.okResponse);
    }
    if (message.denyResponse !== undefined) {
      obj.denyResponse = DenyResponseMessage.toJSON(message.denyResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Packet>, I>>(base?: I): Packet {
    return Packet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Packet>, I>>(object: I): Packet {
    const message = createBasePacket();
    message.senderId = object.senderId ?? 0;
    message.roomId = object.roomId ?? 0;
    message.chat = (object.chat !== undefined && object.chat !== null)
      ? ChatMessage.fromPartial(object.chat)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? IdMessage.fromPartial(object.id) : undefined;
    message.register = (object.register !== undefined && object.register !== null)
      ? RegisterMessage.fromPartial(object.register)
      : undefined;
    message.unregister = (object.unregister !== undefined && object.unregister !== null)
      ? UnregisterMessage.fromPartial(object.unregister)
      : undefined;
    message.okResponse = (object.okResponse !== undefined && object.okResponse !== null)
      ? OkResponseMessage.fromPartial(object.okResponse)
      : undefined;
    message.denyResponse = (object.denyResponse !== undefined && object.denyResponse !== null)
      ? DenyResponseMessage.fromPartial(object.denyResponse)
      : undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    jwt: undefined,
    login: undefined,
    register: undefined,
    refresh: undefined,
    logout: undefined,
    newRoom: undefined,
    roomsRequest: undefined,
    roomsResponse: undefined,
    okResponse: undefined,
    denyResponse: undefined,
  };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jwt !== undefined) {
      JwtMessage.encode(message.jwt, writer.uint32(10).fork()).join();
    }
    if (message.login !== undefined) {
      LoginRequestMessage.encode(message.login, writer.uint32(18).fork()).join();
    }
    if (message.register !== undefined) {
      RegisterRequestMessage.encode(message.register, writer.uint32(26).fork()).join();
    }
    if (message.refresh !== undefined) {
      RefreshRequestMessage.encode(message.refresh, writer.uint32(34).fork()).join();
    }
    if (message.logout !== undefined) {
      LogoutRequestMessage.encode(message.logout, writer.uint32(42).fork()).join();
    }
    if (message.newRoom !== undefined) {
      NewRoomRequestMessage.encode(message.newRoom, writer.uint32(50).fork()).join();
    }
    if (message.roomsRequest !== undefined) {
      RoomsRequestMessage.encode(message.roomsRequest, writer.uint32(58).fork()).join();
    }
    if (message.roomsResponse !== undefined) {
      RoomsResponseMessage.encode(message.roomsResponse, writer.uint32(66).fork()).join();
    }
    if (message.okResponse !== undefined) {
      OkResponseMessage.encode(message.okResponse, writer.uint32(74).fork()).join();
    }
    if (message.denyResponse !== undefined) {
      DenyResponseMessage.encode(message.denyResponse, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jwt = JwtMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.login = LoginRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.register = RegisterRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refresh = RefreshRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.logout = LogoutRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.newRoom = NewRoomRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.roomsRequest = RoomsRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.roomsResponse = RoomsResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.okResponse = OkResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.denyResponse = DenyResponseMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      jwt: isSet(object.jwt) ? JwtMessage.fromJSON(object.jwt) : undefined,
      login: isSet(object.login) ? LoginRequestMessage.fromJSON(object.login) : undefined,
      register: isSet(object.register) ? RegisterRequestMessage.fromJSON(object.register) : undefined,
      refresh: isSet(object.refresh) ? RefreshRequestMessage.fromJSON(object.refresh) : undefined,
      logout: isSet(object.logout) ? LogoutRequestMessage.fromJSON(object.logout) : undefined,
      newRoom: isSet(object.newRoom) ? NewRoomRequestMessage.fromJSON(object.newRoom) : undefined,
      roomsRequest: isSet(object.roomsRequest) ? RoomsRequestMessage.fromJSON(object.roomsRequest) : undefined,
      roomsResponse: isSet(object.roomsResponse) ? RoomsResponseMessage.fromJSON(object.roomsResponse) : undefined,
      okResponse: isSet(object.okResponse) ? OkResponseMessage.fromJSON(object.okResponse) : undefined,
      denyResponse: isSet(object.denyResponse) ? DenyResponseMessage.fromJSON(object.denyResponse) : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.jwt !== undefined) {
      obj.jwt = JwtMessage.toJSON(message.jwt);
    }
    if (message.login !== undefined) {
      obj.login = LoginRequestMessage.toJSON(message.login);
    }
    if (message.register !== undefined) {
      obj.register = RegisterRequestMessage.toJSON(message.register);
    }
    if (message.refresh !== undefined) {
      obj.refresh = RefreshRequestMessage.toJSON(message.refresh);
    }
    if (message.logout !== undefined) {
      obj.logout = LogoutRequestMessage.toJSON(message.logout);
    }
    if (message.newRoom !== undefined) {
      obj.newRoom = NewRoomRequestMessage.toJSON(message.newRoom);
    }
    if (message.roomsRequest !== undefined) {
      obj.roomsRequest = RoomsRequestMessage.toJSON(message.roomsRequest);
    }
    if (message.roomsResponse !== undefined) {
      obj.roomsResponse = RoomsResponseMessage.toJSON(message.roomsResponse);
    }
    if (message.okResponse !== undefined) {
      obj.okResponse = OkResponseMessage.toJSON(message.okResponse);
    }
    if (message.denyResponse !== undefined) {
      obj.denyResponse = DenyResponseMessage.toJSON(message.denyResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.jwt = (object.jwt !== undefined && object.jwt !== null) ? JwtMessage.fromPartial(object.jwt) : undefined;
    message.login = (object.login !== undefined && object.login !== null)
      ? LoginRequestMessage.fromPartial(object.login)
      : undefined;
    message.register = (object.register !== undefined && object.register !== null)
      ? RegisterRequestMessage.fromPartial(object.register)
      : undefined;
    message.refresh = (object.refresh !== undefined && object.refresh !== null)
      ? RefreshRequestMessage.fromPartial(object.refresh)
      : undefined;
    message.logout = (object.logout !== undefined && object.logout !== null)
      ? LogoutRequestMessage.fromPartial(object.logout)
      : undefined;
    message.newRoom = (object.newRoom !== undefined && object.newRoom !== null)
      ? NewRoomRequestMessage.fromPartial(object.newRoom)
      : undefined;
    message.roomsRequest = (object.roomsRequest !== undefined && object.roomsRequest !== null)
      ? RoomsRequestMessage.fromPartial(object.roomsRequest)
      : undefined;
    message.roomsResponse = (object.roomsResponse !== undefined && object.roomsResponse !== null)
      ? RoomsResponseMessage.fromPartial(object.roomsResponse)
      : undefined;
    message.okResponse = (object.okResponse !== undefined && object.okResponse !== null)
      ? OkResponseMessage.fromPartial(object.okResponse)
      : undefined;
    message.denyResponse = (object.denyResponse !== undefined && object.denyResponse !== null)
      ? DenyResponseMessage.fromPartial(object.denyResponse)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
