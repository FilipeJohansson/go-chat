// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: packets.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "packets";

export interface ChatMessage {
  timestamp: Date | undefined;
  senderUsername: string;
  msg: string;
}

export interface IdMessage {
  id: number;
  username: string;
}

export interface RegisterMessage {
  id: number;
  username: string;
}

export interface UnregisterMessage {
  id: number;
}

export interface LoginRequestMessage {
  username: string;
  password: string;
}

export interface RegisterRequestMessage {
  username: string;
  password: string;
}

export interface RefreshRequestMessage {
  refreshToken: string;
}

export interface OkResponseMessage {
}

export interface DenyResponseMessage {
  reason: string;
}

export interface JwtMessage {
  accessToken: string;
  refreshToken: string;
}

export interface Packet {
  senderId: number;
  chat?: ChatMessage | undefined;
  id?: IdMessage | undefined;
  register?: RegisterMessage | undefined;
  unregister?: UnregisterMessage | undefined;
  loginRequest?: LoginRequestMessage | undefined;
  registerRequest?: RegisterRequestMessage | undefined;
  refreshRequest?: RefreshRequestMessage | undefined;
  okResponse?: OkResponseMessage | undefined;
  denyResponse?: DenyResponseMessage | undefined;
  jwt?: JwtMessage | undefined;
}

function createBaseChatMessage(): ChatMessage {
  return { timestamp: undefined, senderUsername: "", msg: "" };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(message: ChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.senderUsername !== "") {
      writer.uint32(18).string(message.senderUsername);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderUsername = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      senderUsername: isSet(object.senderUsername) ? globalThis.String(object.senderUsername) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.senderUsername !== "") {
      obj.senderUsername = message.senderUsername;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.timestamp = object.timestamp ?? undefined;
    message.senderUsername = object.senderUsername ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseIdMessage(): IdMessage {
  return { id: 0, username: "" };
}

export const IdMessage: MessageFns<IdMessage> = {
  encode(message: IdMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: IdMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdMessage>, I>>(base?: I): IdMessage {
    return IdMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdMessage>, I>>(object: I): IdMessage {
    const message = createBaseIdMessage();
    message.id = object.id ?? 0;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseRegisterMessage(): RegisterMessage {
  return { id: 0, username: "" };
}

export const RegisterMessage: MessageFns<RegisterMessage> = {
  encode(message: RegisterMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: RegisterMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterMessage>, I>>(base?: I): RegisterMessage {
    return RegisterMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterMessage>, I>>(object: I): RegisterMessage {
    const message = createBaseRegisterMessage();
    message.id = object.id ?? 0;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseUnregisterMessage(): UnregisterMessage {
  return { id: 0 };
}

export const UnregisterMessage: MessageFns<UnregisterMessage> = {
  encode(message: UnregisterMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnregisterMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterMessage {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: UnregisterMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnregisterMessage>, I>>(base?: I): UnregisterMessage {
    return UnregisterMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnregisterMessage>, I>>(object: I): UnregisterMessage {
    const message = createBaseUnregisterMessage();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseLoginRequestMessage(): LoginRequestMessage {
  return { username: "", password: "" };
}

export const LoginRequestMessage: MessageFns<LoginRequestMessage> = {
  encode(message: LoginRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequestMessage {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginRequestMessage): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequestMessage>, I>>(base?: I): LoginRequestMessage {
    return LoginRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequestMessage>, I>>(object: I): LoginRequestMessage {
    const message = createBaseLoginRequestMessage();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRegisterRequestMessage(): RegisterRequestMessage {
  return { username: "", password: "" };
}

export const RegisterRequestMessage: MessageFns<RegisterRequestMessage> = {
  encode(message: RegisterRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequestMessage {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: RegisterRequestMessage): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterRequestMessage>, I>>(base?: I): RegisterRequestMessage {
    return RegisterRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterRequestMessage>, I>>(object: I): RegisterRequestMessage {
    const message = createBaseRegisterRequestMessage();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRefreshRequestMessage(): RefreshRequestMessage {
  return { refreshToken: "" };
}

export const RefreshRequestMessage: MessageFns<RefreshRequestMessage> = {
  encode(message: RefreshRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshRequestMessage {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshRequestMessage): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshRequestMessage>, I>>(base?: I): RefreshRequestMessage {
    return RefreshRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshRequestMessage>, I>>(object: I): RefreshRequestMessage {
    const message = createBaseRefreshRequestMessage();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseOkResponseMessage(): OkResponseMessage {
  return {};
}

export const OkResponseMessage: MessageFns<OkResponseMessage> = {
  encode(_: OkResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OkResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOkResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OkResponseMessage {
    return {};
  },

  toJSON(_: OkResponseMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OkResponseMessage>, I>>(base?: I): OkResponseMessage {
    return OkResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OkResponseMessage>, I>>(_: I): OkResponseMessage {
    const message = createBaseOkResponseMessage();
    return message;
  },
};

function createBaseDenyResponseMessage(): DenyResponseMessage {
  return { reason: "" };
}

export const DenyResponseMessage: MessageFns<DenyResponseMessage> = {
  encode(message: DenyResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyResponseMessage {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: DenyResponseMessage): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DenyResponseMessage>, I>>(base?: I): DenyResponseMessage {
    return DenyResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DenyResponseMessage>, I>>(object: I): DenyResponseMessage {
    const message = createBaseDenyResponseMessage();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseJwtMessage(): JwtMessage {
  return { accessToken: "", refreshToken: "" };
}

export const JwtMessage: MessageFns<JwtMessage> = {
  encode(message: JwtMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtMessage {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: JwtMessage): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtMessage>, I>>(base?: I): JwtMessage {
    return JwtMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtMessage>, I>>(object: I): JwtMessage {
    const message = createBaseJwtMessage();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBasePacket(): Packet {
  return {
    senderId: 0,
    chat: undefined,
    id: undefined,
    register: undefined,
    unregister: undefined,
    loginRequest: undefined,
    registerRequest: undefined,
    refreshRequest: undefined,
    okResponse: undefined,
    denyResponse: undefined,
    jwt: undefined,
  };
}

export const Packet: MessageFns<Packet> = {
  encode(message: Packet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.senderId !== 0) {
      writer.uint32(8).uint64(message.senderId);
    }
    if (message.chat !== undefined) {
      ChatMessage.encode(message.chat, writer.uint32(18).fork()).join();
    }
    if (message.id !== undefined) {
      IdMessage.encode(message.id, writer.uint32(26).fork()).join();
    }
    if (message.register !== undefined) {
      RegisterMessage.encode(message.register, writer.uint32(34).fork()).join();
    }
    if (message.unregister !== undefined) {
      UnregisterMessage.encode(message.unregister, writer.uint32(42).fork()).join();
    }
    if (message.loginRequest !== undefined) {
      LoginRequestMessage.encode(message.loginRequest, writer.uint32(50).fork()).join();
    }
    if (message.registerRequest !== undefined) {
      RegisterRequestMessage.encode(message.registerRequest, writer.uint32(58).fork()).join();
    }
    if (message.refreshRequest !== undefined) {
      RefreshRequestMessage.encode(message.refreshRequest, writer.uint32(66).fork()).join();
    }
    if (message.okResponse !== undefined) {
      OkResponseMessage.encode(message.okResponse, writer.uint32(74).fork()).join();
    }
    if (message.denyResponse !== undefined) {
      DenyResponseMessage.encode(message.denyResponse, writer.uint32(82).fork()).join();
    }
    if (message.jwt !== undefined) {
      JwtMessage.encode(message.jwt, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Packet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.senderId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chat = ChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = IdMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.register = RegisterMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unregister = UnregisterMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.loginRequest = LoginRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.registerRequest = RegisterRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.refreshRequest = RefreshRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.okResponse = OkResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.denyResponse = DenyResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.jwt = JwtMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Packet {
    return {
      senderId: isSet(object.senderId) ? globalThis.Number(object.senderId) : 0,
      chat: isSet(object.chat) ? ChatMessage.fromJSON(object.chat) : undefined,
      id: isSet(object.id) ? IdMessage.fromJSON(object.id) : undefined,
      register: isSet(object.register) ? RegisterMessage.fromJSON(object.register) : undefined,
      unregister: isSet(object.unregister) ? UnregisterMessage.fromJSON(object.unregister) : undefined,
      loginRequest: isSet(object.loginRequest) ? LoginRequestMessage.fromJSON(object.loginRequest) : undefined,
      registerRequest: isSet(object.registerRequest)
        ? RegisterRequestMessage.fromJSON(object.registerRequest)
        : undefined,
      refreshRequest: isSet(object.refreshRequest) ? RefreshRequestMessage.fromJSON(object.refreshRequest) : undefined,
      okResponse: isSet(object.okResponse) ? OkResponseMessage.fromJSON(object.okResponse) : undefined,
      denyResponse: isSet(object.denyResponse) ? DenyResponseMessage.fromJSON(object.denyResponse) : undefined,
      jwt: isSet(object.jwt) ? JwtMessage.fromJSON(object.jwt) : undefined,
    };
  },

  toJSON(message: Packet): unknown {
    const obj: any = {};
    if (message.senderId !== 0) {
      obj.senderId = Math.round(message.senderId);
    }
    if (message.chat !== undefined) {
      obj.chat = ChatMessage.toJSON(message.chat);
    }
    if (message.id !== undefined) {
      obj.id = IdMessage.toJSON(message.id);
    }
    if (message.register !== undefined) {
      obj.register = RegisterMessage.toJSON(message.register);
    }
    if (message.unregister !== undefined) {
      obj.unregister = UnregisterMessage.toJSON(message.unregister);
    }
    if (message.loginRequest !== undefined) {
      obj.loginRequest = LoginRequestMessage.toJSON(message.loginRequest);
    }
    if (message.registerRequest !== undefined) {
      obj.registerRequest = RegisterRequestMessage.toJSON(message.registerRequest);
    }
    if (message.refreshRequest !== undefined) {
      obj.refreshRequest = RefreshRequestMessage.toJSON(message.refreshRequest);
    }
    if (message.okResponse !== undefined) {
      obj.okResponse = OkResponseMessage.toJSON(message.okResponse);
    }
    if (message.denyResponse !== undefined) {
      obj.denyResponse = DenyResponseMessage.toJSON(message.denyResponse);
    }
    if (message.jwt !== undefined) {
      obj.jwt = JwtMessage.toJSON(message.jwt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Packet>, I>>(base?: I): Packet {
    return Packet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Packet>, I>>(object: I): Packet {
    const message = createBasePacket();
    message.senderId = object.senderId ?? 0;
    message.chat = (object.chat !== undefined && object.chat !== null)
      ? ChatMessage.fromPartial(object.chat)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? IdMessage.fromPartial(object.id) : undefined;
    message.register = (object.register !== undefined && object.register !== null)
      ? RegisterMessage.fromPartial(object.register)
      : undefined;
    message.unregister = (object.unregister !== undefined && object.unregister !== null)
      ? UnregisterMessage.fromPartial(object.unregister)
      : undefined;
    message.loginRequest = (object.loginRequest !== undefined && object.loginRequest !== null)
      ? LoginRequestMessage.fromPartial(object.loginRequest)
      : undefined;
    message.registerRequest = (object.registerRequest !== undefined && object.registerRequest !== null)
      ? RegisterRequestMessage.fromPartial(object.registerRequest)
      : undefined;
    message.refreshRequest = (object.refreshRequest !== undefined && object.refreshRequest !== null)
      ? RefreshRequestMessage.fromPartial(object.refreshRequest)
      : undefined;
    message.okResponse = (object.okResponse !== undefined && object.okResponse !== null)
      ? OkResponseMessage.fromPartial(object.okResponse)
      : undefined;
    message.denyResponse = (object.denyResponse !== undefined && object.denyResponse !== null)
      ? DenyResponseMessage.fromPartial(object.denyResponse)
      : undefined;
    message.jwt = (object.jwt !== undefined && object.jwt !== null) ? JwtMessage.fromPartial(object.jwt) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
